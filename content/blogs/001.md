---
title: "System Design for Blog with Massive Users"
date: 2022-05-16T01:39:17+07:00
draft: true
author:
tags:
    - "blog"
    - "story"
    - "research"
description:
toc:
---
Một bài tập và là một vấn đề vô cùng thú vị trong những ngày đầu của hành trình Fresher tại ZaloPay - VNG. <!--more-->

## Problem statement

Câu chuyện về ZaloPay hay VNG mình xin phép được kể sau ở những bài viết khác. Hiện tại, mình sẽ chỉ tập trung vào phần giải quyết vấn đề đã đặt ra ở tiêu đề hơn là kể chuyện, và nó cũng chính là một trong những bài tập của tuần training đầu tiên tại ZaloPay. 

> Imagine you have to design a system for serving blogs to massive readers (10k tps). How would you design the system?

## Analysis

10k *tps*? *tps* ở đây là gì nhỉ? 10k users à?

Sau một hồi tìm hiểu thì mình biết rằng *tps* có các ý nghĩa khác nhau trong các lĩnh vực khác nhau và ở đây ta hiểu *tps* chính là từ viết tắt của *Transaction Per Second*. 

Vì vậy, vấn đề ở đây đặt ra rằng system của chúng ta phải handle được tầm 10k truy vấn/transaction đồng thời, tức là phục vụ cho khoảng 10,000 người như các bạn ở đây cùng đọc tại một thời điểm. 

Ta sẽ cùng nhau trả lời một số câu hỏi để có cái nhìn tổng quan hơn về hệ thống mà ta đang muốn thiết kế.

1. *Who is going to use it?* Các bạn, các đọc giả thân yêu của tôi :blush:
2. *How are they going to use it?* Truy cập, lướt, đọc, điều hướng, lặp lại.
3. *How many users are there?* Sure là phải hơn số lượng 10k tps, cứ cho là 100,000 - 1M users nhé :kissing:
4. *What does the system do?* Gửi/nhận các request từ người dùng, lưu trữ/cập nhật dữ liệu bài viết, xử lí lượng lớn truy vấn, v.v.
5. *What are the inputs and outputs of the system?* Đầu vào là truy vấn từ người dùng, đầu ra là nội dung của trang web, bài viết tương ứng với truy vấn.
6.  *How much data do we expect to handle?* Blog cá nhân, mình viết đến năm 100 tuổi thì ước chừng 1TB chắc là đủ (bao gồm cả text, script, hình ảnh, ...)
7.  *How many requests per second do we expect?* 10,000 tps
8.  *What is the expected read to write ratio?* 10000:1 

Kì vọng cho system của chúng ta, mình sẽ tóm gọn như sau:
- **Scalability**: có khả năng đáp ứng và xử lí lượng lớn user với tốc độ ổn định.
- **Availability**: luôn có thứ để hiển thị cho user, có thể không phải là nội dung mới nhất nhưng vẫn đảm bảo việc luôn hiển thị cho user.
- **Partition Tolerance**: hệ thống vẫn tiếp tục hoạt động trong trường hợp có lỗi xảy ra.

## Solution

Chúng ta sẽ tiếp cận ở góc độ high-level về hệ thống mà chúng ta đang nhắm tới, phân rã nó theo từng scenario và mức growth nhất định.

### Basic system (10 to 100 users)

Hãy bắt đầu với một thiết kế cơ bản nhất của hệ thống chúng ta, một blog dành cho 10 đến 100 users. 

![Basic system](/images/blogs/001/basic.png) 

Công việc lúc này là vô cùng đơn giản khi ta có thể setup một self-host server hoặc ở đâu đó trên cloud, và khi user cần truy cập vào trang web của chúng ta, DNS lúc này sẽ vào việc và trả về địa chỉ IP của server, qua đó trả về dữ liệu tương ứng cho user (HTML, CSS, Script, nội dung blog, v.v.). 

Như chúng ta thấy, dữ liệu của system được lưu trữ tại server, có thể là các folder chứa các tệp text, hình ảnh, v.v. Hoặc là một NoSQL database được cấu hình sẵn (*sử dụng NoSQL vì dữ liệu của blog có tính semi-structured và tổng dung lượng tăng trưởng dự kiến khoảng 1TB*), điều này tiềm ẩn một số rủi ro nhất định, tuy nhiên giải pháp vẫn có thể chấp nhận được với ít chi phí + nỗ lực nhất, và performance ở đây cũng tương tự, có thể chấp nhận được.

### Scale up to 10,000 users & 100 to 500 tps!

Lúc này, blog chúng ta đã lớn mạnh, lượng user đã đạt tới con số 10,000 và throughput (thông lượng) cần đáp ứng khoảng 100-500 tps. 

Và đây chính là lúc mà chúng ta thật sự cần quan tâm đến scalability, scale cái gì, scale như thế nào, để đạt được hiệu quả.

#### Server Scaling

Ban đầu, ta chỉ sử dụng một server duy nhất vì một lí do đơn giản là lượng user chưa nhiều -> số lượng truy vấn phát sinh không nhiều. 

Nhưng hiện tại, lượng user đã tăng trưởng lên gấp 10 -> số lượng truy vấn tăng -> nếu dùng single server thì sẽ tăng khối lượng công việc cho worker (server) -> tăng latency -> giảm performance. Tệ hơn là server có thể bị overload, dẫn đến hỏng hóc -> nguy cơ mất sạch dữ liệu tăng cao.

Giải pháp ở đây là phải tăng khả năng giải quyết và xử lí công việc của worker, để thuận lợi hơn ta sẽ sử dụng các cloud service để giảm thiểu chi phí bảo trì, bảo dưỡng và vận hành. Tiếp theo đó ta có 2 options để lựa chọn cho việc Server Scaling:
- *Vertical Scaling*: upgrade phần cứng, thêm RAM, RAM và RAM, sử dụng CPU tốc độ cao hơn, etc.
- *Horizontal Scaling*: ta sử dụng thêm các máy server, kết nối chúng lại với nhau và tạo thành một hệ thống distributed.

Ở đây, mình sẽ lựa chọn giải pháp ở sau, *Horizontal Scaling*, vì một số lí do chính sau:
- Thường thì sẽ có lợi hơn về mặc chi phí.
- Tạo tiền đề cho việc scale khi tiếp tục tăng trưởng và có nhu cầu.
- Tăng khả năng chịu lỗi của system, hệ thống vẫn có thể hoạt động tiếp tục nếu có 1 vài sự cố xảy ra với một trong các server -> giảm downtime.

![Scale up level 1](/images/blogs/001/intermediate.png)

#### Database Scaling

Ở góc độ Database, liệu chúng ta có cần phải scailing như cách chúng ta đã làm với Server? 

Well, để trả lời câu hỏi này, chúng ta hãy nhìn lại các câu hỏi đã được nêu ra ở trên. Vì đặc điểm của application (blog), việc tăng trưởng user sẽ không làm tăng số lượng dữ liệu phát sinh tương ứng, mà chỉ làm tăng số lượng transaction giữa client và server, tương đương với việc tăng số lượng truy vấn của server lên database, ngoài ra khối lượng dữ liệu dự đoán là không quá lớn (1TB). Thế nên, ở mức tăng trưởng user này, ta chỉ cần optimize truy vấn và tăng tốc độ truy vấn của server với database. Ở đây mình sẽ sử dụng thêm Cache Layer và cấu hình lại logic truy vấn của server.

